# Java 程式設計待加強知識點

根據您完成的練習題與程式碼審查的結果，以下是建議您可以進一步深入學習和鞏固的知識領域。掌握這些要點將能讓您的程式碼更健壯、更專業、更易於維護。

---

### 1. 資料型別與數值精度 (Data Types & Numerical Precision)

這是本次審查中最常出現的問題。精確地處理數字是程式設計的基礎。

- **整數除法 vs. 浮點數除法**:
  - **問題**: 在 `Q110` 和 `Q610` 中，出現了 `int / int` 的情況（例如 `5 / 2` 或 `yearPay / 12`），這會導致結果被無條件捨去小數（得到 `2` 而非 `2.5`）。
  - **建議**: 當您預期結果可能包含小數時，務必確保運算式中至少有一個數是浮點數（`double` 或 `float`），例如 `5 / 2.0` 或 `(double)yearPay / 12`，以觸發浮點數除法。

- **數值溢位 (Integer Overflow)**:
  - **問題**: 在 `Q402`（階乘）中，`13!` 的結果就已經超過 `int` 型別的最大值，導致計算結果錯誤。
  - **建議**: 在處理可能會快速增長的數值（如階乘、費波那契數列）時，要對資料型別的範圍有概念。當 `int` 不足時，應立即考慮使用 `long`。如果 `long` 也不足，Java 提供了 `BigInteger` 類別來處理任意大的整數。

- **金融與費用計算**:
  - **問題**: 在 `Q606` 和 `Q610` 的薪資加總中，使用 `int` 型別來累加 `double` 型別的薪資，會導致精度損失。
  - **建議**: 所有涉及金錢或需要精密小數的計算，都應優先使用 `double` 型別。

### 2. 物件導向設計原則 (Object-Oriented Design Principles)

您在 `Q606` 和 `Q610` 中展現了良好的 OOP 基礎，但可以在以下原則上做得更好。

- **指令與查詢分離 (Command-Query Separation, CQS)**:
  - **問題**: `Q610` 的 `monthTaxed()` 方法既回傳了稅額（查詢），又修改了靜態的總稅額 `sum`（指令）。這導致了嚴重的副作用，每次呼叫都會意外地修改全局狀態，造成重複計算。
  - **建議**: 嚴格區分「只回傳資料而不改變狀態」的方法和「只改變狀態而不回傳資料」的方法。一個方法最好只做一件事。

- **封裝 (Encapsulation)**:
  - **問題**: `Q606` 的 `Teacher` 類別中的屬性使用了預設的 package-private 存取權限。
  - **建議**: 養成將類別屬性設為 `private` 或 `protected` 的習慣。`private` 代表只有類別內部能存取，`protected` 代表類別內部及其子類別可以存取。這能防止外部程式碼意外地修改物件狀態。

- **DRY (Don't Repeat Yourself)**:
  - **問題**: `Q606` 的 `FullTime` 和 `PartTime` 類別中存在完全相同的 `getAfterTaxIns()` 方法。
  - **建議**: 將重複的程式碼提升到父類別中。如果邏輯對所有子類別都適用，它就應該存在於父類別。

- **`static` 的正確使用**:
  - **問題**: `Q610` 的 `getAverageTax()` 方法只操作靜態變數，但卻被定義為實例方法，並透過 `employees.get(0).getAverageTax()` 這樣奇怪的方式呼叫。
  - **建議**: 只依賴靜態變數的工具性方法應該被定義為 `static` 方法，並透過類別名稱直接呼叫（`Employee.getAverageTax()`）。

### 3. 邏輯的完整性與邊界條件 (Logical Completeness & Edge Cases)

- **問題**: 在 `Q202` 的兩數比較和 `Q606`, `Q610` 的薪資比較中，都只處理了 `>` 的情況，而忽略了兩者相等 (`==`) 的可能性。
- **建議**: 在進行比較時，永遠要考慮「大於」、「小於」和「等於」三種情況，確保邏輯的完整性。

### 4. 演算法的正確實作 (Correct Algorithm Implementation)

- **問題**:
  1. `Q508` 中，您實作的排序演算法並非題目要求的「氣泡排序」。
  2. `Q402` 中，您實作的遞迴並非題目要求的「尾遞迴」。
- **建議**: 在實作特定演算法或資料結構時，務必先清晰地理解其定義和運作步驟。例如，氣泡排序的關鍵是「相鄰元素比較」，而尾遞迴的關鍵是「遞迴呼叫是函式最後執行的動作」。

### 5. 錯誤與例外處理 (Error & Exception Handling)

- **問題**:
  1. `Q310` 中，捕捉到輸入格式錯誤後直接 `break`，導致程式流程錯誤。
  2. `Q610` 中，在迴圈內部 `try-catch` 例外，使得程式在拋出「總薪資超額」的例外後仍然繼續執行。
- **建議**:
  1. 在需要使用者重新輸入的場景，`catch` 到例外後應提示使用者、清除無效輸入，並使用 `continue` 繼續下一輪迴圈。
  2. 思考例外的目的。如果一個例外代表整個操作應被終止，`try-catch` 區塊就應該放在迴圈的外部。

---

### 6. 效能與程式碼品質 (Performance & Code Quality)

在 `Test01` 的練習中，您的程式碼功能都已達成，我們可以開始關注更高層次的問題：如何讓程式跑得更快、寫得更專業。

- **`static` 關鍵字的副作用 (Side Effects of `static`)**:
  - **問題**: 在 `Q03` 的 `ShippingDB` 中，`HashMap` 被宣告為 `static`。這會導致所有 `ShippingDB` 的實例（instances）共享同一個資料庫，可能引發意想不到的資料共用問題。
  - **建議**: 深入理解 `static` 的意義——它屬於「類別」本身，而不是某個「物件」。當物件應該各自擁有自己的資料時（例如，每個 `ShippingDB` 應該有自己的包裹清單），其欄位就不應該是 `static` 的。

- **演算法效率 (Algorithmic Efficiency)**:
  - **問題**: 在 `Q03` 的 `findHeaviestPackage` 方法中，您在 `for` 迴圈內部使用了 `shipping.get()`，這會增加不必要的查詢次數。
  - **建議**: 在設計迴圈操作時，思考如何用最少的步驟完成任務。例如，可以設定一個變數來「記住」當前找到的最佳目標（如此處的最重包裹），避免在迴圈中進行重複或昂貴的查找操作。

- **避免重複計算 (Avoiding Redundant Computations)**:
  - **問題**: 在 `Q03` 的 `main` 方法中，`shipping.findHeaviestPackage()` 這個需要遍歷集合的方法被呼叫了數次。
  - **建議**: 如果一個方法的計算結果在短時間內不會改變，且該方法計算成本較高，應先將其結果儲存在一個區域變數中，然後重複使用該變數。這是一個簡單卻極為有效的效能最佳化手段。

- **程式碼簡潔性 (Code Cleanliness)**:
  - **問題**: 在 `OversizePackage` 類別中，宣告了 `overweightfee` 變數但從未使用。
  - **建議**: 定期審視並移除「無用程式碼」（dead code），包括未使用的變數、方法或類別。這能讓程式碼更易於閱讀和維護。

---
將以上幾點融會貫通，您的程式設計能力將會有質的飛躍。加油！